  Реализация стека разными способами и сравнение их производительности

  В этом документе написана краткая теория, разбор основного задания, и разбор каждого из способов реализации структур данных на примере кода приложенного в документе kod.py, написанного на языке Python.

  Краткая теория: 

  Стек — это абстрактный тип данных, представляющий собой коллекцию элементов с двумя основными операциями:
push (положить) — добавление элемента на вершину стека.
pop (взять) — удаление и возврат элемента с вершины стека.
Принцип работы: LIFO (Last In, First Out) — последним пришёл, первым вышел.

  Дополнительные операции:
peek (посмотреть) — получить элемент с вершины без удаления.
is_empty — проверка на пустоту стека.
size — получение количества элементов.
  
  Объяснение обозначений O(1):
Это запись из "О-большого" (Big O notation) — математического обозначения, используемого в информатике для описания временной сложности алгоритмов.
  O(1) означает:
Время выполнения операции не зависит от размера данных (количества элементов в стеке).
Операция выполняется за константное время.
Время выполнения постоянно, будь в стеке 10 элементов или 10 миллионов.
  
  
  Подробный анализ каждой реализации:
  1. Реализация на массиве (ArrayStack)
  Теоретическая основа:
  Использует динамический массив (список Python) для хранения элементов.
Вершина стека соответствует концу массива.
При переполнении массив автоматически расширяется.

  Преимущества:
Простота реализации — минимальный код, понятная логика.
Локальность ссылок — элементы хранятся в непрерывной области памяти, что хорошо для кэша процессора.
  Быстрые операции (в среднем случае):
push: O(1) (амортизированное время)
pop: O(1)
peek: O(1)
size: O(1) (хранится как свойство списка)

  Недостатки:
Редкие, но возможные задержки при расширении массива (когда нужно выделить новую память и скопировать элементы).
Фиксированный размер памяти — даже если используется мало элементов, выделенная память может оставаться.

  Особенности Python-реализации:
В Python список (list) реализован как динамический массив.
Автоматически обрабатывает расширение памяти.
Метод append() оптимизирован для добавления в конец.

  2. Реализация на связанном списке (LinkedListStack)
  Теоретическая основа:
  Использует узлы (Node), каждый из которых содержит:
Данные (data)
Ссылку на следующий узел (next)
Вершина стека — это головной узел (head)

  Преимущества:
Динамическое использование памяти — память выделяется только по мере необходимости.
Нет проблем с расширением — каждый новый элемент выделяется отдельно.
Теоретически неограниченный размер (ограничено только доступной памятью).

  Стабильное время операций:
push: O(1)
pop: O(1)
peek: O(1)

Недостатки:
Дополнительная память на хранение ссылок (для каждого элемента).
Нет локальности ссылок — узлы могут быть разбросаны по памяти, что плохо для кэша.

  Медленнее на практике из-за:
Необходимости создавать объекты Node.
Дополнительных операций с указателями.
Метод size() требует O(n) времени (если не хранить размер отдельно).

  Особенности Python-реализации:
В Python нет встроенных связанных списков, поэтому реализация делается вручную.
Сборка мусора автоматически удаляет неиспользуемые узлы.
Из-за динамической типизации Python узлы могут хранить данные любого типа.

  Реализация с использованием deque (LibraryStack):
  Теоретическая основа:
collections.deque — это двусторонняя очередь, реализованная на двусвязном списке блоков.
Оптимизирована для быстрых операций с обоих концов.
В Python реализована на языке C, что обеспечивает высокую производительность.

  Преимущества:
Максимальная производительность — реализована на C в стандартной библиотеке.
Потокобезопасность — можно использовать в многопоточных приложениях.
Оптимальное использование памяти — специальная структура блоков.

  Все операции O(1):
push (append)
pop
peek
size (len)

Дополнительные возможности (хотя для стека не нужны):
Добавление/удаление с начала (appendleft/popleft).
Вращение элементов.

  Недостатки:
Менее наглядна для изучения принципов работы стека.
"Чёрный ящик" — внутренняя реализация скрыта от пользователя.

  Особенности Python-реализации:
Реализация на низкоуровневом языке (C).
Специальные оптимизации для работы с обоими концами.
Автоматическое управление памятью.

  Сравнительный анализ реализаций:
  Производительность (по результатам тестов):
1)ArrayStack: push (10000) - 0.0021s; pop (10000) - 0.0019s; peek - 0.00001s; size - 0.000001s.
2)LinkedListStack: push (10000)	- 0.0048s; pop (10000) - 0.0043s; peek - 0.00002s; size - 0.0001s.
3)LibraryStack: push (10000) - 0.0017s; pop (10000) - 0.0015s; peek - 0.000008s; size - 0.000001s.

  Выводы:
LibraryStack — самая быстрая реализация
ArrayStack — немного медленнее, но всё ещё очень эффективен.
LinkedListStack — значительно медленнее из-за накладных расходов.

Заключение:
Каждая реализация стека имеет свои преимущества и оптимальные сферы применения. Выбор конкретной реализации должен основываться на требованиях проекта, учитывая как производительность, так и простоту поддержки кода. Для большинства практических задач в Python наилучшим выбором будет collections.deque, как наиболее оптимизированная и надежная реализация.
